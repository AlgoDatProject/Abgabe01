package ab3.impl.Oraze_RÃ¶ttl_Miklau;

import ab3.AB3;

import java.util.List;
import java.util.Set;

public class AB3Impl implements AB3 {

    @Override
    public SearchInfoKMP findPatternKMP(String text, String pattern) {
        return null;
    }

    @Override
    public List<Integer> findPatternEndlAutomat(String text, String pattern) {
        return null;
    }

    @Override
    public Set<SymbolCode> huffmanCoding(List<Character> symbols, List<Integer> frequency) {
        //sort symbols according to frequency
        sortFrequency(symbols, frequency);
        MinHeap tree = new MinHeap(frequency.size());
        //add nodes to tree
        for (int i = 0; i < symbols.size(); i++) {
            tree.add(new HuffmanNode(frequency.get(i), symbols.get(i)));
        }
        //loop which generates the huffman tree
        while (tree.size > 1){
            tree.createInternalNode();
        }




        return null;
    }

    public void getMinHeap(List<HuffmanNode> tree) {

    }

    //for sorting arrays
    public void sortFrequency(List<Character> symbols, List<Integer> frequency) {

        //dividing our length each time by 2 will decrease the gap distance every iteration and eventually end in a gap of only 1
        for (int gap = frequency.size() / 2; gap > 0; gap /= 2) {

            //iterate over the elements on the right half of the gap
            for (int right = gap; right < frequency.size(); right++) {

                //to store the current value of the element which will be later compared and
                //the index of the current gap value
                int compare = frequency.get(right);
                int temp = right;
                char compareChar = symbols.get(right);

                while (temp >= gap && frequency.get(temp - gap) > compare) {

                    //while is only executed if the two elements separated by the gap are in the wrong order
                    //then it switches the lower one to the right place
                    frequency.set(temp, frequency.get(temp - gap));
                    symbols.set(temp, symbols.get(temp - gap));

                    //reducing temp by the gap amount ensures that while loop will break after temp gets lower than gap
                    temp -= gap;
                }

                //now the lesser number has two switch to the left
                frequency.set(temp, compare);
                symbols.set(temp, compareChar);
            }
        }
    }

    /**
     * data structure which is used to traverse tree generated by huffman algorithm to determine code
     */
    public class HuffmanNode {

        int frequency;
        char symbol;

        HuffmanNode left;
        HuffmanNode right;

        public HuffmanNode(int frequency, char symbol) {
            this.frequency = frequency;
            this.symbol = symbol;
        }

        public HuffmanNode(int frequency) {
            this.frequency = frequency;
        }
    }

    /**
     * modified min heap data class for huffman algorithm at any time
     */
    public class MinHeap{

        private HuffmanNode[] heap;
        private int size;
        private int pointer;

        public MinHeap(int size) {
            this.size = size;
            heap = new HuffmanNode[size];
            pointer = 0;
        }

        private HuffmanNode parent(int pos) {
            return heap[pos / 2];
        }

        private HuffmanNode leftChild(int pos) {
            return heap[(2 * pos)];
        }

        private HuffmanNode rightChild(int pos) {
            return heap[(2 * pos) + 1];
        }

        public void add(HuffmanNode node) {
            if (pointer >= size) {
                throw new ArrayIndexOutOfBoundsException();
            } else {
                heap[pointer++] = node;
            }
        }

        public void createInternalNode() {
            int frequencyNew = heap[0].frequency + heap[1].frequency;
            HuffmanNode node = new HuffmanNode(frequencyNew);
            node.left = heap[0];
            node.right = heap[1];
            for (int i = 1; i < size - 1; i++) {
                heap[i] = heap[i + 1];
            }
            size--;
            //restore heap
            makeHeap();
        }

        public void makeHeap() {
            for (int i = 0; i < size / 2 - 1; i++) {
                int temp = heap[i].frequency;
                if (temp > leftChild(i).frequency && temp > rightChild(i).frequency) {
                    swap(i, i + 1);
                }
            }
        }

        private void swap(int fPos, int sPos) {
            HuffmanNode tmp;
            tmp = heap[fPos];
            heap[fPos] = heap[sPos];
            heap[sPos] = tmp;
        }
    }

}
